由内核分配给任务的内存才会在任务被删除后自动释放掉，用户分配给任务的内存需要由用户自行释放掉，比如用户申请的内存，必须要自己释放。

如果使用静态方法建立任务，用户必须实现vApplicationGetIdleTaskMemory()和vApplicationGetTimerTaskMemory()两个函数，用来
给空闲任务和定时器任务的任务堆栈、任务控制块分配内存。

任务函数一般不允许跳出循环,如果一定要跳出循环的话在跳出循环以后一定要调用函数 vTaskDelete(NULL)删除此任务!

空闲任务：系统中其他任务由于各种原因不能运行的时候，空闲任务就在运行。空闲任务是FreeRTOS自动创建的，不需要用户手动创建。除此之外，还会做其他的事情：
1)判断系统中是否有任务删除自己，如果有，释放被删除任务的任务堆栈和任务控制块的内存
2)运行用户设置的空闲任务钩子函数
3)开启低功耗模式
空闲任务的优先级是最低的，为0.

当执行延时函数的时候就会进行任务切换,并且此任务就会进入阻塞态,直到延时完成,任务重新进入就绪态。

在 FreeRTOS 中延时函数也有相对模式和绝对模式,不过在 FreeRTOS 中不同的模式用的函数不同,其中函数 vTaskDelay()是相对模式(相对延时函数),
函数 vTaskDelayUntil()是绝对模式(绝对延时函数)。
函数 vTaskDelay()在文件 tasks.c 中有定义,要使用此函数的话宏 INCLUDE_vTaskDelay 必须为 1

互斥信号量使用和二值信号量相同的 API 操作函数,所以互斥信号量也可以设置阻塞时间,不同于二值信号量的是互斥信号量具有优先级继承的特性。当一个互斥信号量正在被一个低优
先级的任务使用,而此时有个高优先级的任务也尝试获取这个互斥信号量的话就会被阻塞。不过这个高优先级的任务会将低优先级任务的优先级提升到与自己相同的优先级,这个过程就是
优先级继承。优先级继承尽可能的降低了高优先级任务处于阻塞态的时间,并且将已经出现的“优先级翻转”的影响降到最低。
优先级继承并不能完全的消除优先级翻转,它只是尽可能的降低优先级翻转带来的影响。

硬实时应用应该在设计之初就要避免优先级翻转的发生。互斥信号量不能用于中断服务函数中,原因如下:
● 互斥信号量有优先级继承的机制,所以只能用在任务中,不能用于中断服务函数。
● 中断服务函数中不能因为要等待互斥信号量而设置阻塞时间进入阻塞态。